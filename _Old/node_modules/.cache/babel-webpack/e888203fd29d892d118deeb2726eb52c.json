{"ast":null,"code":"import { Observable, BehaviorSubject, of, from } from 'rxjs';\nimport { concatMap, first } from 'rxjs/operators';\nimport { getStatusText, isSuccess, STATUS } from './http-status-codes';\nimport { delayResponse } from './delay-response';\nimport { InMemoryBackendConfig, parseUri, removeTrailingSlash } from './interfaces';\n/**\r\n * Base class for in-memory web api back-ends\r\n * Simulate the behavior of a RESTy web api\r\n * backed by the simple in-memory data store provided by the injected `InMemoryDbService` service.\r\n * Conforms mostly to behavior described here:\r\n * http://www.restapitutorial.com/lessons/httpmethods.html\r\n */\n\nvar BackendService =\n/** @class */\nfunction () {\n  function BackendService(inMemDbService, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.inMemDbService = inMemDbService;\n    this.config = new InMemoryBackendConfig();\n    this.requestInfoUtils = this.getRequestInfoUtils();\n    var loc = this.getLocation('/');\n    this.config.host = loc.host; // default to app web server host\n\n    this.config.rootPath = loc.path; // default to path when app is served (e.g.'/')\n\n    Object.assign(this.config, config);\n  }\n\n  Object.defineProperty(BackendService.prototype, \"dbReady\", {\n    ////  protected /////\n    get: function get() {\n      if (!this.dbReadySubject) {\n        // first time the service is called.\n        this.dbReadySubject = new BehaviorSubject(false);\n        this.resetDb();\n      }\n\n      return this.dbReadySubject.asObservable().pipe(first(function (r) {\n        return r;\n      }));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Process Request and return an Observable of Http Response object\r\n   * in the manner of a RESTy web api.\r\n   *\r\n   * Expect URI pattern in the form :base/:collectionName/:id?\r\n   * Examples:\r\n   *   // for store with a 'customers' collection\r\n   *   GET api/customers          // all customers\r\n   *   GET api/customers/42       // the character with id=42\r\n   *   GET api/customers?name=^j  // 'j' is a regex; returns customers whose name starts with 'j' or 'J'\r\n   *   GET api/customers.json/42  // ignores the \".json\"\r\n   *\r\n   * Also accepts direct commands to the service in which the last segment of the apiBase is the word \"commands\"\r\n   * Examples:\r\n   *     POST commands/resetDb,\r\n   *     GET/POST commands/config - get or (re)set the config\r\n   *\r\n   *   HTTP overrides:\r\n   *     If the injected inMemDbService defines an HTTP method (lowercase)\r\n   *     The request is forwarded to that method as in\r\n   *     `inMemDbService.get(requestInfo)`\r\n   *     which must return either an Observable of the response type\r\n   *     for this http library or null|undefined (which means \"keep processing\").\r\n   */\n\n  BackendService.prototype.handleRequest = function (req) {\n    var _this = this; //  handle the request when there is an in-memory database\n\n\n    return this.dbReady.pipe(concatMap(function () {\n      return _this.handleRequest_(req);\n    }));\n  };\n\n  BackendService.prototype.handleRequest_ = function (req) {\n    var _this = this;\n\n    var url = req.urlWithParams ? req.urlWithParams : req.url; // Try override parser\n    // If no override parser or it returns nothing, use default parser\n\n    var parser = this.bind('parseRequestUrl');\n    var parsed = parser && parser(url, this.requestInfoUtils) || this.parseRequestUrl(url);\n    var collectionName = parsed.collectionName;\n    var collection = this.db[collectionName];\n    var reqInfo = {\n      req: req,\n      apiBase: parsed.apiBase,\n      collection: collection,\n      collectionName: collectionName,\n      headers: this.createHeaders({\n        'Content-Type': 'application/json'\n      }),\n      id: this.parseId(collection, collectionName, parsed.id),\n      method: this.getRequestMethod(req),\n      query: parsed.query,\n      resourceUrl: parsed.resourceUrl,\n      url: url,\n      utils: this.requestInfoUtils\n    };\n    var resOptions;\n\n    if (/commands\\/?$/i.test(reqInfo.apiBase)) {\n      return this.commands(reqInfo);\n    }\n\n    var methodInterceptor = this.bind(reqInfo.method);\n\n    if (methodInterceptor) {\n      // InMemoryDbService intercepts this HTTP method.\n      // if interceptor produced a response, return it.\n      // else InMemoryDbService chose not to intercept; continue processing.\n      var interceptorResponse = methodInterceptor(reqInfo);\n\n      if (interceptorResponse) {\n        return interceptorResponse;\n      }\n\n      ;\n    }\n\n    if (this.db[collectionName]) {\n      // request is for a known collection of the InMemoryDbService\n      return this.createResponse$(function () {\n        return _this.collectionHandler(reqInfo);\n      });\n    }\n\n    if (this.config.passThruUnknownUrl) {\n      // unknown collection; pass request thru to a \"real\" backend.\n      return this.getPassThruBackend().handle(req);\n    } // 404 - can't handle this request\n\n\n    resOptions = this.createErrorResponseOptions(url, STATUS.NOT_FOUND, \"Collection '\" + collectionName + \"' not found\");\n    return this.createResponse$(function () {\n      return resOptions;\n    });\n  };\n  /**\r\n   * Add configured delay to response observable unless delay === 0\r\n   */\n\n\n  BackendService.prototype.addDelay = function (response) {\n    var d = this.config.delay;\n    return d === 0 ? response : delayResponse(response, d || 500);\n  };\n  /**\r\n   * Apply query/search parameters as a filter over the collection\r\n   * This impl only supports RegExp queries on string properties of the collection\r\n   * ANDs the conditions together\r\n   */\n\n\n  BackendService.prototype.applyQuery = function (collection, query) {\n    // extract filtering conditions - {propertyName, RegExps) - from query/search parameters\n    var conditions = [];\n    var caseSensitive = this.config.caseSensitiveSearch ? undefined : 'i';\n    query.forEach(function (value, name) {\n      value.forEach(function (v) {\n        return conditions.push({\n          name: name,\n          rx: new RegExp(decodeURI(v), caseSensitive)\n        });\n      });\n    });\n    var len = conditions.length;\n\n    if (!len) {\n      return collection;\n    } // AND the RegExp conditions\n\n\n    return collection.filter(function (row) {\n      var ok = true;\n      var i = len;\n\n      while (ok && i) {\n        i -= 1;\n        var cond = conditions[i];\n        ok = cond.rx.test(row[cond.name]);\n      }\n\n      return ok;\n    });\n  };\n  /**\r\n   * Get a method from the `InMemoryDbService` (if it exists), bound to that service\r\n   */\n\n\n  BackendService.prototype.bind = function (methodName) {\n    var fn = this.inMemDbService[methodName];\n    return fn ? fn.bind(this.inMemDbService) : undefined;\n  };\n\n  BackendService.prototype.bodify = function (data) {\n    return this.config.dataEncapsulation ? {\n      data: data\n    } : data;\n  };\n\n  BackendService.prototype.clone = function (data) {\n    return JSON.parse(JSON.stringify(data));\n  };\n\n  BackendService.prototype.collectionHandler = function (reqInfo) {\n    // const req = reqInfo.req;\n    var resOptions;\n\n    switch (reqInfo.method) {\n      case 'get':\n        resOptions = this.get(reqInfo);\n        break;\n\n      case 'post':\n        resOptions = this.post(reqInfo);\n        break;\n\n      case 'put':\n        resOptions = this.put(reqInfo);\n        break;\n\n      case 'delete':\n        resOptions = this.delete(reqInfo);\n        break;\n\n      default:\n        resOptions = this.createErrorResponseOptions(reqInfo.url, STATUS.METHOD_NOT_ALLOWED, 'Method not allowed');\n        break;\n    } // If `inMemDbService.responseInterceptor` exists, let it morph the response options\n\n\n    var interceptor = this.bind('responseInterceptor');\n    return interceptor ? interceptor(resOptions, reqInfo) : resOptions;\n  };\n  /**\r\n   * Commands reconfigure the in-memory web api service or extract information from it.\r\n   * Commands ignore the latency delay and respond ASAP.\r\n   *\r\n   * When the last segment of the `apiBase` path is \"commands\",\r\n   * the `collectionName` is the command.\r\n   *\r\n   * Example URLs:\r\n   *   commands/resetdb (POST) // Reset the \"database\" to its original state\r\n   *   commands/config (GET)   // Return this service's config object\r\n   *   commands/config (POST)  // Update the config (e.g. the delay)\r\n   *\r\n   * Usage:\r\n   *   http.post('commands/resetdb', undefined);\r\n   *   http.get('commands/config');\r\n   *   http.post('commands/config', '{\"delay\":1000}');\r\n   */\n\n\n  BackendService.prototype.commands = function (reqInfo) {\n    var _this = this;\n\n    var command = reqInfo.collectionName.toLowerCase();\n    var method = reqInfo.method;\n    var resOptions = {\n      url: reqInfo.url\n    };\n\n    switch (command) {\n      case 'resetdb':\n        resOptions.status = STATUS.NO_CONTENT;\n        return this.resetDb(reqInfo).pipe(concatMap(function () {\n          return _this.createResponse$(function () {\n            return resOptions;\n          }, false\n          /* no latency delay */\n          );\n        }));\n\n      case 'config':\n        if (method === 'get') {\n          resOptions.status = STATUS.OK;\n          resOptions.body = this.clone(this.config); // any other HTTP method is assumed to be a config update\n        } else {\n          var body = this.getJsonBody(reqInfo.req);\n          Object.assign(this.config, body);\n          this.passThruBackend = undefined; // re-create when needed\n\n          resOptions.status = STATUS.NO_CONTENT;\n        }\n\n        break;\n\n      default:\n        resOptions = this.createErrorResponseOptions(reqInfo.url, STATUS.INTERNAL_SERVER_ERROR, \"Unknown command \\\"\" + command + \"\\\"\");\n    }\n\n    return this.createResponse$(function () {\n      return resOptions;\n    }, false\n    /* no latency delay */\n    );\n  };\n\n  BackendService.prototype.createErrorResponseOptions = function (url, status, message) {\n    return {\n      body: {\n        error: \"\" + message\n      },\n      url: url,\n      headers: this.createHeaders({\n        'Content-Type': 'application/json'\n      }),\n      status: status\n    };\n  };\n  /**\r\n   * Create a cold response Observable from a factory for ResponseOptions\r\n   * @param resOptionsFactory - creates ResponseOptions when observable is subscribed\r\n   * @param withDelay - if true (default), add simulated latency delay from configuration\r\n   */\n\n\n  BackendService.prototype.createResponse$ = function (resOptionsFactory, withDelay) {\n    if (withDelay === void 0) {\n      withDelay = true;\n    }\n\n    var resOptions$ = this.createResponseOptions$(resOptionsFactory);\n    var resp$ = this.createResponse$fromResponseOptions$(resOptions$);\n    return withDelay ? this.addDelay(resp$) : resp$;\n  };\n  /**\r\n   * Create a cold Observable of ResponseOptions.\r\n   * @param resOptionsFactory - creates ResponseOptions when observable is subscribed\r\n   */\n\n\n  BackendService.prototype.createResponseOptions$ = function (resOptionsFactory) {\n    var _this = this;\n\n    return new Observable(function (responseObserver) {\n      var resOptions;\n\n      try {\n        resOptions = resOptionsFactory();\n      } catch (error) {\n        var err = error.message || error;\n        resOptions = _this.createErrorResponseOptions('', STATUS.INTERNAL_SERVER_ERROR, \"\" + err);\n      }\n\n      var status = resOptions.status;\n\n      try {\n        resOptions.statusText = getStatusText(status);\n      } catch (e) {\n        /* ignore failure */\n      }\n\n      if (isSuccess(status)) {\n        responseObserver.next(resOptions);\n        responseObserver.complete();\n      } else {\n        responseObserver.error(resOptions);\n      }\n\n      return function () {}; // unsubscribe function\n    });\n  };\n\n  BackendService.prototype.delete = function (_a) {\n    var collection = _a.collection,\n        collectionName = _a.collectionName,\n        headers = _a.headers,\n        id = _a.id,\n        url = _a.url; // tslint:disable-next-line:triple-equals\n\n    if (id == undefined) {\n      return this.createErrorResponseOptions(url, STATUS.NOT_FOUND, \"Missing \\\"\" + collectionName + \"\\\" id\");\n    }\n\n    var exists = this.removeById(collection, id);\n    return {\n      headers: headers,\n      status: exists || !this.config.delete404 ? STATUS.NO_CONTENT : STATUS.NOT_FOUND\n    };\n  };\n  /**\r\n   * Find first instance of item in collection by `item.id`\r\n   * @param collection\r\n   * @param id\r\n   */\n\n\n  BackendService.prototype.findById = function (collection, id) {\n    return collection.find(function (item) {\n      return item.id === id;\n    });\n  };\n  /**\r\n   * Generate the next available id for item in this collection\r\n   * Use method from `inMemDbService` if it exists and returns a value,\r\n   * else delegates to `genIdDefault`.\r\n   * @param collection - collection of items with `id` key property\r\n   */\n\n\n  BackendService.prototype.genId = function (collection, collectionName) {\n    var genId = this.bind('genId');\n\n    if (genId) {\n      var id = genId(collection, collectionName); // tslint:disable-next-line:triple-equals\n\n      if (id != undefined) {\n        return id;\n      }\n    }\n\n    return this.genIdDefault(collection, collectionName);\n  };\n  /**\r\n   * Default generator of the next available id for item in this collection\r\n   * This default implementation works only for numeric ids.\r\n   * @param collection - collection of items with `id` key property\r\n   * @param collectionName - name of the collection\r\n   */\n\n\n  BackendService.prototype.genIdDefault = function (collection, collectionName) {\n    if (!this.isCollectionIdNumeric(collection, collectionName)) {\n      throw new Error(\"Collection '\" + collectionName + \"' id type is non-numeric or unknown. Can only generate numeric ids.\");\n    }\n\n    var maxId = 0;\n    collection.reduce(function (prev, item) {\n      maxId = Math.max(maxId, typeof item.id === 'number' ? item.id : maxId);\n    }, undefined);\n    return maxId + 1;\n  };\n\n  BackendService.prototype.get = function (_a) {\n    var collection = _a.collection,\n        collectionName = _a.collectionName,\n        headers = _a.headers,\n        id = _a.id,\n        query = _a.query,\n        url = _a.url;\n    var data = collection; // tslint:disable-next-line:triple-equals\n\n    if (id != undefined && id !== '') {\n      data = this.findById(collection, id);\n    } else if (query) {\n      data = this.applyQuery(collection, query);\n    }\n\n    if (!data) {\n      return this.createErrorResponseOptions(url, STATUS.NOT_FOUND, \"'\" + collectionName + \"' with id='\" + id + \"' not found\");\n    }\n\n    return {\n      body: this.bodify(this.clone(data)),\n      headers: headers,\n      status: STATUS.OK\n    };\n  };\n  /**\r\n   * Get location info from a url, even on server where `document` is not defined\r\n   */\n\n\n  BackendService.prototype.getLocation = function (url) {\n    if (!url.startsWith('http')) {\n      // get the document iff running in browser\n      var doc = typeof document === 'undefined' ? undefined : document; // add host info to url before parsing.  Use a fake host when not in browser.\n\n      var base = doc ? doc.location.protocol + '//' + doc.location.host : 'http://fake';\n      url = url.startsWith('/') ? base + url : base + '/' + url;\n    }\n\n    return parseUri(url);\n  };\n\n  ;\n  /**\r\n   * get or create the function that passes unhandled requests\r\n   * through to the \"real\" backend.\r\n   */\n\n  BackendService.prototype.getPassThruBackend = function () {\n    return this.passThruBackend ? this.passThruBackend : this.passThruBackend = this.createPassThruBackend();\n  };\n  /**\r\n   * Get utility methods from this service instance.\r\n   * Useful within an HTTP method override\r\n   */\n\n\n  BackendService.prototype.getRequestInfoUtils = function () {\n    var _this = this;\n\n    return {\n      createResponse$: this.createResponse$.bind(this),\n      findById: this.findById.bind(this),\n      isCollectionIdNumeric: this.isCollectionIdNumeric.bind(this),\n      getConfig: function getConfig() {\n        return _this.config;\n      },\n      getDb: function getDb() {\n        return _this.db;\n      },\n      getJsonBody: this.getJsonBody.bind(this),\n      getLocation: this.getLocation.bind(this),\n      getPassThruBackend: this.getPassThruBackend.bind(this),\n      parseRequestUrl: this.parseRequestUrl.bind(this)\n    };\n  };\n\n  BackendService.prototype.indexOf = function (collection, id) {\n    return collection.findIndex(function (item) {\n      return item.id === id;\n    });\n  };\n  /** Parse the id as a number. Return original value if not a number. */\n\n\n  BackendService.prototype.parseId = function (collection, collectionName, id) {\n    if (!this.isCollectionIdNumeric(collection, collectionName)) {\n      // Can't confirm that `id` is a numeric type; don't parse as a number\n      // or else `'42'` -> `42` and _get by id_ fails.\n      return id;\n    }\n\n    var idNum = parseFloat(id);\n    return isNaN(idNum) ? id : idNum;\n  };\n  /**\r\n   * return true if can determine that the collection's `item.id` is a number\r\n   * This implementation can't tell if the collection is empty so it assumes NO\r\n   * */\n\n\n  BackendService.prototype.isCollectionIdNumeric = function (collection, collectionName) {\n    // collectionName not used now but override might maintain collection type information\n    // so that it could know the type of the `id` even when the collection is empty.\n    return !!(collection && collection[0]) && typeof collection[0].id === 'number';\n  };\n  /**\r\n   * Parses the request URL into a `ParsedRequestUrl` object.\r\n   * Parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.\r\n   *\r\n   * Configuring the `apiBase` yields the most interesting changes to `parseRequestUrl` behavior:\r\n   *   When apiBase=undefined and url='http://localhost/api/collection/42'\r\n   *     {base: 'api/', collectionName: 'collection', id: '42', ...}\r\n   *   When apiBase='some/api/root/' and url='http://localhost/some/api/root/collection'\r\n   *     {base: 'some/api/root/', collectionName: 'collection', id: undefined, ...}\r\n   *   When apiBase='/' and url='http://localhost/collection'\r\n   *     {base: '/', collectionName: 'collection', id: undefined, ...}\r\n   *\r\n   * The actual api base segment values are ignored. Only the number of segments matters.\r\n   * The following api base strings are considered identical: 'a/b' ~ 'some/api/' ~ `two/segments'\r\n   *\r\n   * To replace this default method, assign your alternative to your InMemDbService['parseRequestUrl']\r\n   */\n\n\n  BackendService.prototype.parseRequestUrl = function (url) {\n    try {\n      var loc = this.getLocation(url);\n      var drop = this.config.rootPath.length;\n      var urlRoot = '';\n\n      if (loc.host !== this.config.host) {\n        // url for a server on a different host!\n        // assume it's collection is actually here too.\n        drop = 1; // the leading slash\n\n        urlRoot = loc.protocol + '//' + loc.host + '/';\n      }\n\n      var path = loc.path.substring(drop);\n      var pathSegments = path.split('/');\n      var segmentIx = 0; // apiBase: the front part of the path devoted to getting to the api route\n      // Assumes first path segment if no config.apiBase\n      // else ignores as many path segments as are in config.apiBase\n      // Does NOT care what the api base chars actually are.\n\n      var apiBase = void 0; // tslint:disable-next-line:triple-equals\n\n      if (this.config.apiBase == undefined) {\n        apiBase = pathSegments[segmentIx++];\n      } else {\n        apiBase = removeTrailingSlash(this.config.apiBase.trim());\n\n        if (apiBase) {\n          segmentIx = apiBase.split('/').length;\n        } else {\n          segmentIx = 0; // no api base at all; unwise but allowed.\n        }\n      }\n\n      apiBase += '/';\n      var collectionName = pathSegments[segmentIx++]; // ignore anything after a '.' (e.g.,the \"json\" in \"customers.json\")\n\n      collectionName = collectionName && collectionName.split('.')[0];\n      var id = pathSegments[segmentIx++];\n      var query = this.createQueryMap(loc.query);\n      var resourceUrl = urlRoot + apiBase + collectionName + '/';\n      return {\n        apiBase: apiBase,\n        collectionName: collectionName,\n        id: id,\n        query: query,\n        resourceUrl: resourceUrl\n      };\n    } catch (err) {\n      var msg = \"unable to parse url '\" + url + \"'; original error: \" + err.message;\n      throw new Error(msg);\n    }\n  }; // Create entity\n  // Can update an existing entity too if post409 is false.\n\n\n  BackendService.prototype.post = function (_a) {\n    var collection = _a.collection,\n        collectionName = _a.collectionName,\n        headers = _a.headers,\n        id = _a.id,\n        req = _a.req,\n        resourceUrl = _a.resourceUrl,\n        url = _a.url;\n    var item = this.clone(this.getJsonBody(req)); // tslint:disable-next-line:triple-equals\n\n    if (item.id == undefined) {\n      try {\n        item.id = id || this.genId(collection, collectionName);\n      } catch (err) {\n        var emsg = err.message || '';\n\n        if (/id type is non-numeric/.test(emsg)) {\n          return this.createErrorResponseOptions(url, STATUS.UNPROCESSABLE_ENTRY, emsg);\n        } else {\n          console.error(err);\n          return this.createErrorResponseOptions(url, STATUS.INTERNAL_SERVER_ERROR, \"Failed to generate new id for '\" + collectionName + \"'\");\n        }\n      }\n    }\n\n    if (id && id !== item.id) {\n      return this.createErrorResponseOptions(url, STATUS.BAD_REQUEST, \"Request id does not match item.id\");\n    } else {\n      id = item.id;\n    }\n\n    var existingIx = this.indexOf(collection, id);\n    var body = this.bodify(item);\n\n    if (existingIx === -1) {\n      collection.push(item);\n      headers.set('Location', resourceUrl + '/' + id);\n      return {\n        headers: headers,\n        body: body,\n        status: STATUS.CREATED\n      };\n    } else if (this.config.post409) {\n      return this.createErrorResponseOptions(url, STATUS.CONFLICT, \"'\" + collectionName + \"' item with id='\" + id + \" exists and may not be updated with POST; use PUT instead.\");\n    } else {\n      collection[existingIx] = item;\n      return this.config.post204 ? {\n        headers: headers,\n        status: STATUS.NO_CONTENT\n      } : // successful; no content\n      {\n        headers: headers,\n        body: body,\n        status: STATUS.OK\n      }; // successful; return entity\n    }\n  }; // Update existing entity\n  // Can create an entity too if put404 is false.\n\n\n  BackendService.prototype.put = function (_a) {\n    var collection = _a.collection,\n        collectionName = _a.collectionName,\n        headers = _a.headers,\n        id = _a.id,\n        req = _a.req,\n        url = _a.url;\n    var item = this.clone(this.getJsonBody(req)); // tslint:disable-next-line:triple-equals\n\n    if (item.id == undefined) {\n      return this.createErrorResponseOptions(url, STATUS.NOT_FOUND, \"Missing '\" + collectionName + \"' id\");\n    }\n\n    if (id && id !== item.id) {\n      return this.createErrorResponseOptions(url, STATUS.BAD_REQUEST, \"Request for '\" + collectionName + \"' id does not match item.id\");\n    } else {\n      id = item.id;\n    }\n\n    var existingIx = this.indexOf(collection, id);\n    var body = this.bodify(item);\n\n    if (existingIx > -1) {\n      collection[existingIx] = item;\n      return this.config.put204 ? {\n        headers: headers,\n        status: STATUS.NO_CONTENT\n      } : // successful; no content\n      {\n        headers: headers,\n        body: body,\n        status: STATUS.OK\n      }; // successful; return entity\n    } else if (this.config.put404) {\n      // item to update not found; use POST to create new item for this id.\n      return this.createErrorResponseOptions(url, STATUS.NOT_FOUND, \"'\" + collectionName + \"' item with id='\" + id + \" not found and may not be created with PUT; use POST instead.\");\n    } else {\n      // create new item for id not found\n      collection.push(item);\n      return {\n        headers: headers,\n        body: body,\n        status: STATUS.CREATED\n      };\n    }\n  };\n\n  BackendService.prototype.removeById = function (collection, id) {\n    var ix = this.indexOf(collection, id);\n\n    if (ix > -1) {\n      collection.splice(ix, 1);\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Tell your in-mem \"database\" to reset.\r\n   * returns Observable of the database because resetting it could be async\r\n   */\n\n\n  BackendService.prototype.resetDb = function (reqInfo) {\n    var _this = this;\n\n    this.dbReadySubject.next(false);\n    var db = this.inMemDbService.createDb(reqInfo);\n    var db$ = db instanceof Observable ? db : typeof db.then === 'function' ? from(db) : of(db);\n    db$.pipe(first()).subscribe(function (d) {\n      _this.db = d;\n\n      _this.dbReadySubject.next(true);\n    });\n    return this.dbReady;\n  };\n\n  return BackendService;\n}();\n\nexport { BackendService };","map":{"version":3,"sources":["backend.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, Observer, BehaviorSubject, of, from } from 'rxjs';\nimport { concatMap, first } from 'rxjs/operators';\n\nimport { getStatusText, isSuccess, STATUS } from './http-status-codes';\nimport { delayResponse } from './delay-response';\n\nimport {\n  HeadersCore,\n  RequestInfoUtilities,\n  InMemoryDbService,\n  InMemoryBackendConfig,\n  InMemoryBackendConfigArgs,\n  ParsedRequestUrl,\n  parseUri,\n  PassThruBackend,\n  removeTrailingSlash,\n  RequestCore,\n  RequestInfo,\n  ResponseOptions,\n  UriInfo\n} from './interfaces';\n\n/**\n * Base class for in-memory web api back-ends\n * Simulate the behavior of a RESTy web api\n * backed by the simple in-memory data store provided by the injected `InMemoryDbService` service.\n * Conforms mostly to behavior described here:\n * http://www.restapitutorial.com/lessons/httpmethods.html\n */\nexport abstract class BackendService {\n  protected config: InMemoryBackendConfigArgs = new InMemoryBackendConfig();\n  protected db: Object;\n  protected dbReadySubject: BehaviorSubject<boolean>;\n  private passThruBackend: PassThruBackend;\n  protected requestInfoUtils = this.getRequestInfoUtils();\n\n  constructor(\n    protected inMemDbService: InMemoryDbService,\n    config: InMemoryBackendConfigArgs = {}\n  ) {\n    const loc = this.getLocation('/');\n    this.config.host = loc.host;     // default to app web server host\n    this.config.rootPath = loc.path; // default to path when app is served (e.g.'/')\n    Object.assign(this.config, config);\n  }\n\n  ////  protected /////\n  protected get dbReady(): Observable<boolean> {\n    if (!this.dbReadySubject) {\n      // first time the service is called.\n      this.dbReadySubject = new BehaviorSubject(false);\n      this.resetDb();\n    }\n    return this.dbReadySubject.asObservable().pipe(first((r: boolean) => r));\n  }\n\n  /**\n   * Process Request and return an Observable of Http Response object\n   * in the manner of a RESTy web api.\n   *\n   * Expect URI pattern in the form :base/:collectionName/:id?\n   * Examples:\n   *   // for store with a 'customers' collection\n   *   GET api/customers          // all customers\n   *   GET api/customers/42       // the character with id=42\n   *   GET api/customers?name=^j  // 'j' is a regex; returns customers whose name starts with 'j' or 'J'\n   *   GET api/customers.json/42  // ignores the \".json\"\n   *\n   * Also accepts direct commands to the service in which the last segment of the apiBase is the word \"commands\"\n   * Examples:\n   *     POST commands/resetDb,\n   *     GET/POST commands/config - get or (re)set the config\n   *\n   *   HTTP overrides:\n   *     If the injected inMemDbService defines an HTTP method (lowercase)\n   *     The request is forwarded to that method as in\n   *     `inMemDbService.get(requestInfo)`\n   *     which must return either an Observable of the response type\n   *     for this http library or null|undefined (which means \"keep processing\").\n   */\n  protected handleRequest(req: RequestCore): Observable<any> {\n    //  handle the request when there is an in-memory database\n    return this.dbReady.pipe(concatMap(() => this.handleRequest_(req)));\n  }\n\n  protected handleRequest_(req: RequestCore): Observable<any> {\n\n    const url = req.urlWithParams ? req.urlWithParams : req.url;\n\n    // Try override parser\n    // If no override parser or it returns nothing, use default parser\n    const parser = this.bind('parseRequestUrl');\n    const parsed: ParsedRequestUrl =\n      ( parser && parser(url, this.requestInfoUtils)) ||\n      this.parseRequestUrl(url);\n\n    const collectionName = parsed.collectionName;\n    const collection = this.db[collectionName];\n\n    const reqInfo: RequestInfo = {\n      req: req,\n      apiBase: parsed.apiBase,\n      collection: collection,\n      collectionName: collectionName,\n      headers: this.createHeaders({ 'Content-Type': 'application/json' }),\n      id: this.parseId(collection, collectionName, parsed.id),\n      method: this.getRequestMethod(req),\n      query: parsed.query,\n      resourceUrl: parsed.resourceUrl,\n      url: url,\n      utils: this.requestInfoUtils\n    };\n\n    let resOptions: ResponseOptions;\n\n    if (/commands\\/?$/i.test(reqInfo.apiBase)) {\n      return this.commands(reqInfo);\n    }\n\n    const methodInterceptor = this.bind(reqInfo.method);\n    if (methodInterceptor) {\n      // InMemoryDbService intercepts this HTTP method.\n      // if interceptor produced a response, return it.\n      // else InMemoryDbService chose not to intercept; continue processing.\n      const interceptorResponse = methodInterceptor(reqInfo);\n      if (interceptorResponse) {\n        return interceptorResponse;\n      };\n    }\n\n    if (this.db[collectionName]) {\n      // request is for a known collection of the InMemoryDbService\n      return this.createResponse$(() => this.collectionHandler(reqInfo));\n    }\n\n    if (this.config.passThruUnknownUrl) {\n      // unknown collection; pass request thru to a \"real\" backend.\n      return this.getPassThruBackend().handle(req);\n    }\n\n    // 404 - can't handle this request\n    resOptions = this.createErrorResponseOptions(\n      url,\n      STATUS.NOT_FOUND,\n      `Collection '${collectionName}' not found`\n    );\n    return this.createResponse$(() => resOptions);\n  }\n\n  /**\n   * Add configured delay to response observable unless delay === 0\n   */\n  protected addDelay(response: Observable<any>): Observable<any> {\n    const d = this.config.delay;\n    return d === 0 ? response : delayResponse(response, d || 500);\n  }\n\n  /**\n   * Apply query/search parameters as a filter over the collection\n   * This impl only supports RegExp queries on string properties of the collection\n   * ANDs the conditions together\n   */\n  protected applyQuery(collection: any[], query: Map<string, string[]>): any[] {\n    // extract filtering conditions - {propertyName, RegExps) - from query/search parameters\n    const conditions: { name: string, rx: RegExp }[] = [];\n    const caseSensitive = this.config.caseSensitiveSearch ? undefined : 'i';\n    query.forEach((value: string[], name: string) => {\n      value.forEach(v => conditions.push({ name, rx: new RegExp(decodeURI(v), caseSensitive) }));\n    });\n\n    const len = conditions.length;\n    if (!len) { return collection; }\n\n    // AND the RegExp conditions\n    return collection.filter(row => {\n      let ok = true;\n      let i = len;\n      while (ok && i) {\n        i -= 1;\n        const cond = conditions[i];\n        ok = cond.rx.test(row[cond.name]);\n      }\n      return ok;\n    });\n  }\n\n  /**\n   * Get a method from the `InMemoryDbService` (if it exists), bound to that service\n   */\n  protected bind<T extends Function>(methodName: string) {\n    const fn = this.inMemDbService[methodName] as T;\n    return fn ? <T> fn.bind(this.inMemDbService) : undefined;\n  }\n\n  protected bodify(data: any) {\n    return this.config.dataEncapsulation ? { data } : data;\n  }\n\n  protected clone(data: any) {\n    return JSON.parse(JSON.stringify(data));\n  }\n\n  protected collectionHandler(reqInfo: RequestInfo): ResponseOptions {\n    // const req = reqInfo.req;\n      let resOptions: ResponseOptions;\n      switch (reqInfo.method) {\n        case 'get':\n          resOptions = this.get(reqInfo);\n          break;\n        case 'post':\n          resOptions = this.post(reqInfo);\n          break;\n        case 'put':\n          resOptions = this.put(reqInfo);\n          break;\n        case 'delete':\n          resOptions = this.delete(reqInfo);\n          break;\n        default:\n          resOptions = this.createErrorResponseOptions(reqInfo.url, STATUS.METHOD_NOT_ALLOWED, 'Method not allowed');\n          break;\n      }\n\n      // If `inMemDbService.responseInterceptor` exists, let it morph the response options\n      const interceptor = this.bind('responseInterceptor');\n      return interceptor ? interceptor(resOptions, reqInfo) : resOptions;\n  }\n\n  /**\n   * Commands reconfigure the in-memory web api service or extract information from it.\n   * Commands ignore the latency delay and respond ASAP.\n   *\n   * When the last segment of the `apiBase` path is \"commands\",\n   * the `collectionName` is the command.\n   *\n   * Example URLs:\n   *   commands/resetdb (POST) // Reset the \"database\" to its original state\n   *   commands/config (GET)   // Return this service's config object\n   *   commands/config (POST)  // Update the config (e.g. the delay)\n   *\n   * Usage:\n   *   http.post('commands/resetdb', undefined);\n   *   http.get('commands/config');\n   *   http.post('commands/config', '{\"delay\":1000}');\n   */\n  protected commands(reqInfo: RequestInfo): Observable<any> {\n    const command = reqInfo.collectionName.toLowerCase();\n    const method = reqInfo.method;\n\n    let resOptions: ResponseOptions = {\n      url: reqInfo.url\n    };\n\n    switch (command) {\n      case 'resetdb':\n        resOptions.status = STATUS.NO_CONTENT;\n        return this.resetDb(reqInfo).pipe(\n          concatMap(() => this.createResponse$(() => resOptions, false /* no latency delay */))\n        );\n\n      case 'config':\n        if (method === 'get') {\n          resOptions.status = STATUS.OK;\n          resOptions.body = this.clone(this.config);\n\n        // any other HTTP method is assumed to be a config update\n        } else {\n          const body = this.getJsonBody(reqInfo.req);\n          Object.assign(this.config, body);\n          this.passThruBackend = undefined; // re-create when needed\n\n          resOptions.status = STATUS.NO_CONTENT;\n        }\n        break;\n\n      default:\n        resOptions = this.createErrorResponseOptions(\n          reqInfo.url,\n          STATUS.INTERNAL_SERVER_ERROR,\n          `Unknown command \"${command}\"`\n        );\n    }\n\n    return this.createResponse$(() => resOptions, false /* no latency delay */);\n  }\n\n  protected createErrorResponseOptions(url: string, status: number, message: string): ResponseOptions {\n    return {\n      body: { error: `${message}` },\n      url: url,\n      headers: this.createHeaders({ 'Content-Type': 'application/json' }),\n      status: status\n    };\n  }\n\n  /**\n   * Create standard HTTP headers object from hash map of header strings\n   * @param headers\n   */\n  protected abstract createHeaders(headers: {[index: string]: string}): HeadersCore;\n\n  /**\n   * create the function that passes unhandled requests through to the \"real\" backend.\n   */\n  protected abstract createPassThruBackend(): PassThruBackend;\n\n  /**\n   * return a search map from a location query/search string\n   */\n  protected abstract createQueryMap(search: string): Map<string, string[]>;\n\n  /**\n   * Create a cold response Observable from a factory for ResponseOptions\n   * @param resOptionsFactory - creates ResponseOptions when observable is subscribed\n   * @param withDelay - if true (default), add simulated latency delay from configuration\n   */\n  protected createResponse$(resOptionsFactory: () => ResponseOptions, withDelay = true): Observable<any> {\n    const resOptions$ = this.createResponseOptions$(resOptionsFactory);\n    let resp$ = this.createResponse$fromResponseOptions$(resOptions$);\n    return withDelay ? this.addDelay(resp$) : resp$;\n  }\n\n  /**\n   * Create a Response observable from ResponseOptions observable.\n   */\n  protected abstract createResponse$fromResponseOptions$(resOptions$: Observable<ResponseOptions>): Observable<any>;\n\n  /**\n   * Create a cold Observable of ResponseOptions.\n   * @param resOptionsFactory - creates ResponseOptions when observable is subscribed\n   */\n  protected createResponseOptions$(resOptionsFactory: () => ResponseOptions): Observable<ResponseOptions> {\n\n    return new Observable<ResponseOptions>((responseObserver: Observer<ResponseOptions>) => {\n      let resOptions: ResponseOptions;\n      try {\n        resOptions = resOptionsFactory();\n      } catch (error) {\n        const err = error.message || error;\n        resOptions = this.createErrorResponseOptions('', STATUS.INTERNAL_SERVER_ERROR, `${err}`);\n      }\n\n      const status = resOptions.status;\n      try {\n        resOptions.statusText = getStatusText(status);\n      } catch (e) { /* ignore failure */}\n      if (isSuccess(status)) {\n        responseObserver.next(resOptions);\n        responseObserver.complete();\n      } else {\n        responseObserver.error(resOptions);\n      }\n      return () => { }; // unsubscribe function\n    });\n  }\n\n  protected delete({ collection, collectionName, headers, id, url}: RequestInfo): ResponseOptions {\n    // tslint:disable-next-line:triple-equals\n    if (id == undefined) {\n      return this.createErrorResponseOptions(url, STATUS.NOT_FOUND, `Missing \"${collectionName}\" id`);\n    }\n    const exists = this.removeById(collection, id);\n    return {\n      headers: headers,\n      status: (exists || !this.config.delete404) ? STATUS.NO_CONTENT : STATUS.NOT_FOUND\n    };\n  }\n\n  /**\n   * Find first instance of item in collection by `item.id`\n   * @param collection\n   * @param id\n   */\n  protected findById<T extends { id: any }>(collection: T[], id: any): T {\n    return collection.find((item: T) => item.id === id);\n  }\n\n  /**\n   * Generate the next available id for item in this collection\n   * Use method from `inMemDbService` if it exists and returns a value,\n   * else delegates to `genIdDefault`.\n   * @param collection - collection of items with `id` key property\n   */\n  protected genId<T extends { id: any }>(collection: T[], collectionName: string): any {\n    const genId = this.bind('genId');\n    if (genId) {\n      const id = genId(collection, collectionName);\n      // tslint:disable-next-line:triple-equals\n      if (id != undefined) { return id; }\n    }\n    return this.genIdDefault(collection, collectionName);\n  }\n\n  /**\n   * Default generator of the next available id for item in this collection\n   * This default implementation works only for numeric ids.\n   * @param collection - collection of items with `id` key property\n   * @param collectionName - name of the collection\n   */\n  protected genIdDefault<T extends { id: any }>(collection: T[], collectionName: string): any {\n    if (!this.isCollectionIdNumeric(collection, collectionName)) {\n      throw new Error(\n        `Collection '${collectionName}' id type is non-numeric or unknown. Can only generate numeric ids.`);\n    }\n\n    let maxId = 0;\n    collection.reduce((prev: any, item: any) => {\n      maxId = Math.max(maxId, typeof item.id === 'number' ? item.id : maxId);\n    }, undefined);\n    return maxId + 1;\n  }\n\n  protected get({ collection, collectionName, headers, id, query, url }: RequestInfo): ResponseOptions {\n    let data = collection;\n\n    // tslint:disable-next-line:triple-equals\n    if (id != undefined && id !== '') {\n      data = this.findById(collection, id);\n    } else if (query) {\n      data = this.applyQuery(collection, query);\n    }\n\n    if (!data) {\n      return this.createErrorResponseOptions(url, STATUS.NOT_FOUND, `'${collectionName}' with id='${id}' not found`);\n    }\n    return {\n      body: this.bodify(this.clone(data)),\n      headers: headers,\n      status: STATUS.OK\n    };\n  }\n\n  /** Get JSON body from the request object */\n  protected abstract getJsonBody(req: any): any;\n\n  /**\n   * Get location info from a url, even on server where `document` is not defined\n   */\n  protected getLocation(url: string): UriInfo {\n    if (!url.startsWith('http')) {\n      // get the document iff running in browser\n      const doc: Document = (typeof document === 'undefined') ? undefined : document;\n      // add host info to url before parsing.  Use a fake host when not in browser.\n      const base = doc ? doc.location.protocol + '//' + doc.location.host : 'http://fake';\n      url = url.startsWith('/') ? base + url : base + '/' + url;\n    }\n    return parseUri(url);\n  };\n\n  /**\n   * get or create the function that passes unhandled requests\n   * through to the \"real\" backend.\n   */\n  protected getPassThruBackend(): PassThruBackend {\n    return this.passThruBackend ?\n      this.passThruBackend :\n      this.passThruBackend = this.createPassThruBackend();\n  }\n\n  /**\n   * Get utility methods from this service instance.\n   * Useful within an HTTP method override\n   */\n  protected getRequestInfoUtils(): RequestInfoUtilities {\n    return {\n      createResponse$: this.createResponse$.bind(this),\n      findById: this.findById.bind(this),\n      isCollectionIdNumeric: this.isCollectionIdNumeric.bind(this),\n      getConfig: () => this.config,\n      getDb: () => this.db,\n      getJsonBody: this.getJsonBody.bind(this),\n      getLocation: this.getLocation.bind(this),\n      getPassThruBackend: this.getPassThruBackend.bind(this),\n      parseRequestUrl: this.parseRequestUrl.bind(this),\n    };\n  }\n\n  /**\n   * return canonical HTTP method name (lowercase) from the request object\n   * e.g. (req.method || 'get').toLowerCase();\n   * @param req - request object from the http call\n   *\n   */\n  protected abstract getRequestMethod(req: any): string;\n\n  protected indexOf(collection: any[], id: number) {\n    return collection.findIndex((item: any) => item.id === id);\n  }\n\n  /** Parse the id as a number. Return original value if not a number. */\n  protected parseId(collection: any[], collectionName: string, id: string): any {\n    if (!this.isCollectionIdNumeric(collection, collectionName)) {\n      // Can't confirm that `id` is a numeric type; don't parse as a number\n      // or else `'42'` -> `42` and _get by id_ fails.\n      return id;\n    }\n    const idNum = parseFloat(id);\n    return isNaN(idNum) ? id : idNum;\n  }\n\n  /**\n   * return true if can determine that the collection's `item.id` is a number\n   * This implementation can't tell if the collection is empty so it assumes NO\n   * */\n  protected isCollectionIdNumeric<T extends { id: any }>(collection: T[], collectionName: string): boolean {\n    // collectionName not used now but override might maintain collection type information\n    // so that it could know the type of the `id` even when the collection is empty.\n    return !!(collection && collection[0]) && typeof collection[0].id === 'number';\n  }\n\n  /**\n   * Parses the request URL into a `ParsedRequestUrl` object.\n   * Parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.\n   *\n   * Configuring the `apiBase` yields the most interesting changes to `parseRequestUrl` behavior:\n   *   When apiBase=undefined and url='http://localhost/api/collection/42'\n   *     {base: 'api/', collectionName: 'collection', id: '42', ...}\n   *   When apiBase='some/api/root/' and url='http://localhost/some/api/root/collection'\n   *     {base: 'some/api/root/', collectionName: 'collection', id: undefined, ...}\n   *   When apiBase='/' and url='http://localhost/collection'\n   *     {base: '/', collectionName: 'collection', id: undefined, ...}\n   *\n   * The actual api base segment values are ignored. Only the number of segments matters.\n   * The following api base strings are considered identical: 'a/b' ~ 'some/api/' ~ `two/segments'\n   *\n   * To replace this default method, assign your alternative to your InMemDbService['parseRequestUrl']\n   */\n  protected parseRequestUrl(url: string): ParsedRequestUrl {\n    try {\n      const loc = this.getLocation(url);\n      let drop = this.config.rootPath.length;\n      let urlRoot = '';\n      if (loc.host !== this.config.host) {\n        // url for a server on a different host!\n        // assume it's collection is actually here too.\n        drop = 1; // the leading slash\n        urlRoot = loc.protocol + '//' + loc.host + '/';\n      }\n      const path = loc.path.substring(drop);\n      const pathSegments = path.split('/');\n      let segmentIx = 0;\n\n      // apiBase: the front part of the path devoted to getting to the api route\n      // Assumes first path segment if no config.apiBase\n      // else ignores as many path segments as are in config.apiBase\n      // Does NOT care what the api base chars actually are.\n      let apiBase: string;\n      // tslint:disable-next-line:triple-equals\n      if (this.config.apiBase == undefined) {\n        apiBase = pathSegments[segmentIx++];\n      } else {\n        apiBase = removeTrailingSlash(this.config.apiBase.trim());\n        if (apiBase) {\n          segmentIx = apiBase.split('/').length;\n        } else {\n          segmentIx = 0; // no api base at all; unwise but allowed.\n        }\n      }\n      apiBase += '/';\n\n      let collectionName = pathSegments[segmentIx++];\n      // ignore anything after a '.' (e.g.,the \"json\" in \"customers.json\")\n      collectionName = collectionName && collectionName.split('.')[0];\n\n      const id = pathSegments[segmentIx++];\n      const query = this.createQueryMap(loc.query);\n      const resourceUrl = urlRoot + apiBase + collectionName + '/';\n      return { apiBase, collectionName, id, query, resourceUrl };\n\n    } catch (err) {\n      const msg = `unable to parse url '${url}'; original error: ${err.message}`;\n      throw new Error(msg);\n    }\n  }\n\n  // Create entity\n  // Can update an existing entity too if post409 is false.\n  protected post({ collection, collectionName, headers, id, req, resourceUrl, url }: RequestInfo): ResponseOptions {\n    const item = this.clone(this.getJsonBody(req));\n\n    // tslint:disable-next-line:triple-equals\n    if (item.id == undefined) {\n      try {\n        item.id = id || this.genId(collection, collectionName);\n      } catch (err) {\n        const emsg: string = err.message || '';\n        if (/id type is non-numeric/.test(emsg)) {\n          return this.createErrorResponseOptions(url, STATUS.UNPROCESSABLE_ENTRY, emsg);\n        } else {\n          console.error(err);\n          return this.createErrorResponseOptions(url, STATUS.INTERNAL_SERVER_ERROR,\n            `Failed to generate new id for '${collectionName}'`);\n        }\n      }\n    }\n\n    if (id && id !== item.id) {\n      return this.createErrorResponseOptions(url, STATUS.BAD_REQUEST, `Request id does not match item.id`);\n    } else {\n      id = item.id;\n    }\n    const existingIx = this.indexOf(collection, id);\n    const body = this.bodify(item);\n\n    if (existingIx === -1) {\n      collection.push(item);\n      headers.set('Location', resourceUrl + '/' + id);\n      return { headers, body, status: STATUS.CREATED };\n    } else if (this.config.post409) {\n      return this.createErrorResponseOptions(url, STATUS.CONFLICT,\n        `'${collectionName}' item with id='${id} exists and may not be updated with POST; use PUT instead.`);\n    } else {\n      collection[existingIx] = item;\n      return this.config.post204 ?\n          { headers, status: STATUS.NO_CONTENT } : // successful; no content\n          { headers, body, status: STATUS.OK }; // successful; return entity\n    }\n  }\n\n  // Update existing entity\n  // Can create an entity too if put404 is false.\n  protected put({ collection, collectionName, headers, id, req, url }: RequestInfo): ResponseOptions {\n    const item = this.clone(this.getJsonBody(req));\n    // tslint:disable-next-line:triple-equals\n    if (item.id == undefined) {\n      return this.createErrorResponseOptions(url, STATUS.NOT_FOUND, `Missing '${collectionName}' id`);\n    }\n    if (id && id !== item.id) {\n      return this.createErrorResponseOptions(url, STATUS.BAD_REQUEST,\n        `Request for '${collectionName}' id does not match item.id`);\n    } else {\n      id = item.id;\n    }\n    const existingIx = this.indexOf(collection, id);\n    const body = this.bodify(item);\n\n    if (existingIx > -1) {\n      collection[existingIx] = item;\n      return this.config.put204 ?\n          { headers, status: STATUS.NO_CONTENT } : // successful; no content\n          { headers, body, status: STATUS.OK }; // successful; return entity\n    } else if (this.config.put404) {\n      // item to update not found; use POST to create new item for this id.\n      return this.createErrorResponseOptions(url, STATUS.NOT_FOUND,\n        `'${collectionName}' item with id='${id} not found and may not be created with PUT; use POST instead.`);\n    } else {\n      // create new item for id not found\n      collection.push(item);\n      return { headers, body, status: STATUS.CREATED };\n    }\n  }\n\n  protected removeById(collection: any[], id: number) {\n    const ix = this.indexOf(collection, id);\n    if (ix > -1) {\n      collection.splice(ix, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tell your in-mem \"database\" to reset.\n   * returns Observable of the database because resetting it could be async\n   */\n  protected resetDb(reqInfo?: RequestInfo): Observable<boolean> {\n    this.dbReadySubject.next(false);\n    const db = this.inMemDbService.createDb(reqInfo);\n    const db$ = db instanceof Observable ? db :\n           typeof (db as any).then === 'function' ? from(db as Promise<any>) :\n           of(db);\n    db$.pipe(first()).subscribe((d: {}) => {\n      this.db = d;\n      this.dbReadySubject.next(true);\n    });\n    return this.dbReady;\n  }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}