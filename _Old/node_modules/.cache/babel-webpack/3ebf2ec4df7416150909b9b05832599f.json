{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/git/sportspip/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _createClass from \"C:/git/sportspip/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"C:/git/sportspip/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { ElementRef, ɵɵdefineInjectable, ɵɵinject, INJECTOR, Injectable, Injector, EventEmitter, Directive, Input, Output, HostListener, Component, NgModule } from '@angular/core';\nimport { Overlay, ScrollStrategyOptions, OverlayModule } from '@angular/cdk/overlay';\nimport { ComponentPortal, PortalModule } from '@angular/cdk/portal';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { filter, take } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/overlay';\n\nvar MenuPackage = function MenuPackage(menu, context) {\n  _classCallCheck(this, MenuPackage);\n\n  this.menu = menu;\n  this.context = context;\n};\n\nvar MenuInjector = /*#__PURE__*/function () {\n  function MenuInjector(activeContextMenu, parentInjector, context) {\n    _classCallCheck(this, MenuInjector);\n\n    this.activeContextMenu = activeContextMenu;\n    this.parentInjector = parentInjector;\n    this.context = context;\n    this.menuContext = new MenuPackage(activeContextMenu, context);\n  }\n\n  _createClass(MenuInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue, flags) {\n      if (token === MenuPackage) {\n        return this.menuContext;\n      }\n\n      return this.parentInjector.get(token, notFoundValue, flags);\n    }\n  }]);\n\n  return MenuInjector;\n}();\n\nvar ContextMenuService = /*#__PURE__*/function () {\n  function ContextMenuService(overlay, scrollStrategy, injector) {\n    _classCallCheck(this, ContextMenuService);\n\n    this.overlay = overlay;\n    this.scrollStrategy = scrollStrategy;\n    this.injector = injector;\n    this.menus = [];\n    this.id = 0;\n  }\n  /**\n   *\n   * @param $event triggering event\n   * @param menuComponent the component to be shown\n   * @param submenu is a menu within a menu\n   * @param level if submenu, what level\n   */\n\n\n  _createClass(ContextMenuService, [{\n    key: \"show\",\n    value: function show($event, menuComponent, context, menuClose, menuAction) {\n      var submenu = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      var level = arguments.length > 6 ? arguments[6] : undefined;\n      var target;\n\n      if (!submenu) {\n        this.closeAll();\n        target = {\n          getBoundingClientRect: function getBoundingClientRect() {\n            return {\n              bottom: $event.clientY,\n              height: 0,\n              left: $event.clientX,\n              right: $event.clientX,\n              top: $event.clientY,\n              width: 0\n            };\n          }\n        };\n      } else {\n        // close other submenus\n        this.closeAll(undefined, level);\n        target = $event.target;\n      }\n\n      var el = new ElementRef(target);\n      var positionStrategy = this.overlay.position().flexibleConnectedTo(el).withFlexibleDimensions(false);\n\n      if (!submenu) {\n        positionStrategy.withPositions([{\n          originX: 'start',\n          originY: 'bottom',\n          overlayX: 'start',\n          overlayY: 'top'\n        }, {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'bottom'\n        }, {\n          originX: 'end',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'top'\n        }, {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'end',\n          overlayY: 'top'\n        }, {\n          originX: 'end',\n          originY: 'center',\n          overlayX: 'start',\n          overlayY: 'center'\n        }, {\n          originX: 'start',\n          originY: 'center',\n          overlayX: 'end',\n          overlayY: 'center'\n        }]);\n      } else {\n        positionStrategy.withPositions([{\n          originX: 'end',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'top'\n        }, {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'end',\n          overlayY: 'top'\n        }, {\n          originX: 'end',\n          originY: 'bottom',\n          overlayX: 'start',\n          overlayY: 'bottom'\n        }, {\n          originX: 'start',\n          originY: 'bottom',\n          overlayX: 'end',\n          overlayY: 'bottom'\n        }]);\n      }\n\n      var t = {\n        submenu: submenu,\n        id: this.id++,\n        isMenuHovered: new BehaviorSubject(false),\n        isTriggerHovered: new BehaviorSubject(false)\n      };\n      var menuInjector = new MenuInjector(t, this.injector, context);\n      var componentPortal = new ComponentPortal(menuComponent, undefined, menuInjector);\n      var overlayRef = this.overlay.create({\n        positionStrategy: positionStrategy,\n        panelClass: 'ngx-contextmenu',\n        scrollStrategy: this.scrollStrategy.close()\n      });\n      var component = overlayRef.attach(componentPortal);\n      var res = Object.assign(Object.assign({\n        overlayRef: overlayRef,\n        component: component\n      }, t), {\n        menuClose: menuClose,\n        menuAction: menuAction\n      });\n      this.menus.push(res);\n      return res;\n    }\n  }, {\n    key: \"getCurrentLevel\",\n    value: function getCurrentLevel() {\n      return this.menus.length;\n    }\n  }, {\n    key: \"closeAll\",\n    value: function closeAll(context) {\n      var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      for (var index = idx; index < this.menus.length; index++) {\n        var menu = this.menus[index];\n        this.destroyMenu(menu, context);\n      }\n\n      this.menus.splice(idx, this.menus.length);\n    }\n  }, {\n    key: \"destroyMenu\",\n    value: function destroyMenu(menu, context) {\n      menu.component.instance._state = 'exit';\n\n      if (menu.component.instance.lazy) {\n        menu.component.instance._animationDone.pipe(filter(function (event) {\n          return event.toState === 'exit';\n        }), take(1)).subscribe(function () {\n          menu.overlayRef.detach();\n          menu.overlayRef.dispose();\n        });\n      } else {\n        menu.overlayRef.detach();\n        menu.overlayRef.dispose();\n      }\n\n      if (context) {\n        menu.menuAction.next(context);\n      }\n\n      menu.menuClose.next();\n    }\n  }, {\n    key: \"close\",\n    value: function close(menu, menuIndex, context) {\n      this.destroyMenu(menu, context);\n      this.menus.splice(menuIndex, 1);\n    }\n  }, {\n    key: \"checkOutsideClick\",\n    value: function checkOutsideClick($event) {\n      var _iterator = _createForOfIteratorHelper(this.menus),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var m = _step.value;\n          var clickedInside = m.component.location.nativeElement.contains($event.target);\n\n          if (clickedInside) {\n            $event.preventDefault();\n            $event.stopPropagation();\n            return;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.closeAll();\n    }\n  }, {\n    key: \"closeSubMenu\",\n    value: function closeSubMenu(id) {\n      var menuIndex = this.menus.findIndex(function (n) {\n        return n.id === id;\n      });\n\n      if (menuIndex === -1 || menuIndex !== this.menus.length - 1) {\n        return;\n      } // make sure we can close the current menu\n\n\n      var menu = this.menus[menuIndex];\n\n      if (menu.isMenuHovered.getValue() || menu.isTriggerHovered.getValue()) {\n        return;\n      } // close all menus up if possible\n\n\n      for (var index = this.menus.length - 1; index >= 1; index--) {\n        var m = this.menus[index];\n\n        if (!m.isMenuHovered.getValue() && !m.isTriggerHovered.getValue()) {\n          this.close(m, index);\n        } else {\n          return;\n        }\n      }\n    }\n  }]);\n\n  return ContextMenuService;\n}();\n\nContextMenuService.ɵfac = function ContextMenuService_Factory(t) {\n  return new (t || ContextMenuService)(ɵngcc0.ɵɵinject(ɵngcc1.Overlay), ɵngcc0.ɵɵinject(ɵngcc1.ScrollStrategyOptions), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n};\n\nContextMenuService.ɵprov = ɵɵdefineInjectable({\n  factory: function ContextMenuService_Factory() {\n    return new ContextMenuService(ɵɵinject(Overlay), ɵɵinject(ScrollStrategyOptions), ɵɵinject(INJECTOR));\n  },\n  token: ContextMenuService,\n  providedIn: \"root\"\n});\n\nContextMenuService.ctorParameters = function () {\n  return [{\n    type: Overlay\n  }, {\n    type: ScrollStrategyOptions\n  }, {\n    type: Injector\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc1.Overlay\n    }, {\n      type: ɵngcc1.ScrollStrategyOptions\n    }, {\n      type: ɵngcc0.Injector\n    }];\n  }, null);\n})();\n\nvar ContextMenuTriggerDirective = /*#__PURE__*/function () {\n  function ContextMenuTriggerDirective(contextMenuService) {\n    _classCallCheck(this, ContextMenuTriggerDirective);\n\n    this.contextMenuService = contextMenuService;\n    this.holdToDisplay = 1000;\n    this.menuAction = new EventEmitter();\n    this.menuClose = new EventEmitter();\n    this.beforeOpen = new EventEmitter();\n    this.visible = false;\n  }\n\n  _createClass(ContextMenuTriggerDirective, [{\n    key: \"handleMenu\",\n    value: function handleMenu($event) {\n      var _preventOpen = false;\n      this.beforeOpen.emit({\n        menuContext: this.menuContext,\n        event: $event,\n        preventOpen: function preventOpen() {\n          _preventOpen = true;\n        }\n      });\n\n      if (_preventOpen) {\n        return;\n      }\n\n      $event.preventDefault();\n      this.menu = this.contextMenuService.show($event, this.contextMenuTrigger, this.menuContext, this.menuClose, this.menuAction);\n      this.visible = true;\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown($event) {\n      var _this = this;\n\n      if (this.holdToDisplay >= 0) {\n        $event.stopPropagation();\n        $event.clientY = $event.touches[0].clientY;\n        $event.clientX = $event.touches[0].clientX;\n        this.mouseDownTimeoutId = setTimeout(function () {\n          return _this.handleMenu($event);\n        }, this.holdToDisplay);\n      }\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp() {\n      clearTimeout(this.mouseDownTimeoutId);\n    }\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this2 = this;\n\n      this.sub = this.menuClose.subscribe(function () {\n        return _this2.visible = false;\n      });\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.sub.unsubscribe();\n    }\n  }]);\n\n  return ContextMenuTriggerDirective;\n}();\n\nContextMenuTriggerDirective.ɵfac = function ContextMenuTriggerDirective_Factory(t) {\n  return new (t || ContextMenuTriggerDirective)(ɵngcc0.ɵɵdirectiveInject(ContextMenuService));\n};\n\nContextMenuTriggerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: ContextMenuTriggerDirective,\n  selectors: [[\"\", \"contextMenuTrigger\", \"\"]],\n  hostBindings: function ContextMenuTriggerDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"contextmenu\", function ContextMenuTriggerDirective_contextmenu_HostBindingHandler($event) {\n        return ctx.handleMenu($event);\n      })(\"touchstart\", function ContextMenuTriggerDirective_touchstart_HostBindingHandler($event) {\n        return ctx.handleMouseDown($event);\n      })(\"touchend\", function ContextMenuTriggerDirective_touchend_HostBindingHandler() {\n        return ctx.handleMouseUp();\n      });\n    }\n  },\n  inputs: {\n    holdToDisplay: \"holdToDisplay\",\n    contextMenuTrigger: \"contextMenuTrigger\",\n    menuContext: \"menuContext\"\n  },\n  outputs: {\n    menuAction: \"menuAction\",\n    menuClose: \"menuClose\",\n    beforeOpen: \"beforeOpen\"\n  },\n  exportAs: [\"contextMenuTrigger\"]\n});\n\nContextMenuTriggerDirective.ctorParameters = function () {\n  return [{\n    type: ContextMenuService\n  }];\n};\n\nContextMenuTriggerDirective.propDecorators = {\n  contextMenuTrigger: [{\n    type: Input\n  }],\n  menuContext: [{\n    type: Input\n  }],\n  holdToDisplay: [{\n    type: Input\n  }],\n  menuAction: [{\n    type: Output\n  }],\n  menuClose: [{\n    type: Output\n  }],\n  beforeOpen: [{\n    type: Output\n  }],\n  handleMenu: [{\n    type: HostListener,\n    args: ['contextmenu', ['$event']]\n  }],\n  handleMouseDown: [{\n    type: HostListener,\n    args: ['touchstart', ['$event']]\n  }],\n  handleMouseUp: [{\n    type: HostListener,\n    args: ['touchend']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuTriggerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[contextMenuTrigger]',\n      exportAs: 'contextMenuTrigger'\n    }]\n  }], function () {\n    return [{\n      type: ContextMenuService\n    }];\n  }, {\n    holdToDisplay: [{\n      type: Input\n    }],\n    menuAction: [{\n      type: Output\n    }],\n    menuClose: [{\n      type: Output\n    }],\n    beforeOpen: [{\n      type: Output\n    }],\n    handleMenu: [{\n      type: HostListener,\n      args: ['contextmenu', ['$event']]\n    }],\n    handleMouseDown: [{\n      type: HostListener,\n      args: ['touchstart', ['$event']]\n    }],\n    handleMouseUp: [{\n      type: HostListener,\n      args: ['touchend']\n    }],\n    contextMenuTrigger: [{\n      type: Input\n    }],\n    menuContext: [{\n      type: Input\n    }]\n  });\n})();\n\nvar ContextSubmenuTriggerDirective = /*#__PURE__*/function () {\n  function ContextSubmenuTriggerDirective(contextMenuService) {\n    var _this3 = this;\n\n    _classCallCheck(this, ContextSubmenuTriggerDirective);\n\n    this.contextMenuService = contextMenuService;\n    this.hoverDelay = 500;\n    this.openDelay = 200;\n    this.menuAction = new EventEmitter();\n    this.menuClose = new EventEmitter();\n    this.visible = false;\n    this.level = 1; // get current level\n\n    setTimeout(function () {\n      return _this3.level = _this3.contextMenuService.getCurrentLevel();\n    });\n  }\n\n  _createClass(ContextSubmenuTriggerDirective, [{\n    key: \"handleSubMenuClick\",\n    value: function handleSubMenuClick($event) {\n      $event.preventDefault();\n      $event.stopPropagation();\n      clearTimeout(this.opentimer);\n      clearTimeout(this.closetimer);\n      this.menu = this.contextMenuService.show($event, this.contextSubmenuTrigger, this.menuContext, this.menuClose, this.menuAction, true, this.level);\n      this.visible = true;\n    }\n  }, {\n    key: \"handleSubMenuEnter\",\n    value: function handleSubMenuEnter($event) {\n      var _this4 = this;\n\n      if (this.menu) {\n        this.menu.isTriggerHovered.next(true);\n      }\n\n      clearTimeout(this.closetimer);\n      this.opentimer = setTimeout(function () {\n        _this4.menu = _this4.contextMenuService.show($event, _this4.contextSubmenuTrigger, _this4.menuContext, _this4.menuClose, _this4.menuAction, true, _this4.level);\n        _this4.visible = true;\n        _this4.opentimer = null;\n      }, this.openDelay);\n    }\n    /**\n     * submenu hides after cursor has exited for a period of time\n     */\n\n  }, {\n    key: \"handleSubMenuExit\",\n    value: function handleSubMenuExit() {\n      var _this5 = this;\n\n      clearTimeout(this.opentimer);\n\n      if (this.menu) {\n        this.menu.isTriggerHovered.next(false);\n      }\n\n      this.closetimer = setTimeout(function () {\n        if (_this5.menu) {\n          _this5.menu.isTriggerHovered.next(false);\n\n          _this5.contextMenuService.closeSubMenu(_this5.menu.id);\n\n          _this5.menu = undefined;\n        }\n\n        _this5.visible = false;\n      }, this.hoverDelay);\n    }\n    /**\n     * if overwritten make sure to clear timeouts\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      clearTimeout(this.opentimer);\n      clearTimeout(this.closetimer);\n    }\n  }]);\n\n  return ContextSubmenuTriggerDirective;\n}();\n\nContextSubmenuTriggerDirective.ɵfac = function ContextSubmenuTriggerDirective_Factory(t) {\n  return new (t || ContextSubmenuTriggerDirective)(ɵngcc0.ɵɵdirectiveInject(ContextMenuService));\n};\n\nContextSubmenuTriggerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: ContextSubmenuTriggerDirective,\n  selectors: [[\"\", \"contextSubmenuTrigger\", \"\"]],\n  hostBindings: function ContextSubmenuTriggerDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"click\", function ContextSubmenuTriggerDirective_click_HostBindingHandler($event) {\n        return ctx.handleSubMenuClick($event);\n      })(\"mouseover\", function ContextSubmenuTriggerDirective_mouseover_HostBindingHandler($event) {\n        return ctx.handleSubMenuEnter($event);\n      })(\"mouseout\", function ContextSubmenuTriggerDirective_mouseout_HostBindingHandler() {\n        return ctx.handleSubMenuExit();\n      });\n    }\n  },\n  inputs: {\n    hoverDelay: \"hoverDelay\",\n    openDelay: \"openDelay\",\n    contextSubmenuTrigger: \"contextSubmenuTrigger\",\n    menuContext: \"menuContext\"\n  },\n  outputs: {\n    menuAction: \"menuAction\",\n    menuClose: \"menuClose\"\n  }\n});\n\nContextSubmenuTriggerDirective.ctorParameters = function () {\n  return [{\n    type: ContextMenuService\n  }];\n};\n\nContextSubmenuTriggerDirective.propDecorators = {\n  hoverDelay: [{\n    type: Input\n  }],\n  openDelay: [{\n    type: Input\n  }],\n  contextSubmenuTrigger: [{\n    type: Input\n  }],\n  menuContext: [{\n    type: Input\n  }],\n  menuAction: [{\n    type: Output\n  }],\n  menuClose: [{\n    type: Output\n  }],\n  handleSubMenuClick: [{\n    type: HostListener,\n    args: ['click', ['$event']]\n  }],\n  handleSubMenuEnter: [{\n    type: HostListener,\n    args: ['mouseover', ['$event']]\n  }],\n  handleSubMenuExit: [{\n    type: HostListener,\n    args: ['mouseout']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextSubmenuTriggerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[contextSubmenuTrigger]'\n    }]\n  }], function () {\n    return [{\n      type: ContextMenuService\n    }];\n  }, {\n    hoverDelay: [{\n      type: Input\n    }],\n    openDelay: [{\n      type: Input\n    }],\n    menuAction: [{\n      type: Output\n    }],\n    menuClose: [{\n      type: Output\n    }],\n    handleSubMenuClick: [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }],\n    handleSubMenuEnter: [{\n      type: HostListener,\n      args: ['mouseover', ['$event']]\n    }],\n\n    /**\n     * submenu hides after cursor has exited for a period of time\n     */\n    handleSubMenuExit: [{\n      type: HostListener,\n      args: ['mouseout']\n    }],\n    contextSubmenuTrigger: [{\n      type: Input\n    }],\n    menuContext: [{\n      type: Input\n    }]\n  });\n})();\n\nvar MenuComponent = /*#__PURE__*/function () {\n  function MenuComponent(menuPackage, contextMenuService) {\n    _classCallCheck(this, MenuComponent);\n\n    this.menuPackage = menuPackage;\n    this.contextMenuService = contextMenuService;\n    /** State of the dialog animation. */\n\n    this._state = 'enter';\n    this._animationDone = new Subject();\n    /** set lazy to False if you do not have animations */\n\n    this.lazy = true;\n  }\n\n  _createClass(MenuComponent, [{\n    key: \"handleMouseover\",\n    value: function handleMouseover() {\n      if (!this.menuPackage.menu.submenu) {\n        return;\n      }\n\n      this.menuPackage.menu.isMenuHovered.next(true);\n      clearTimeout(this.closetimer);\n    }\n  }, {\n    key: \"handleMouseleave\",\n    value: function handleMouseleave() {\n      var _this6 = this;\n\n      if (!this.menuPackage.menu.submenu) {\n        return;\n      }\n\n      this.menuPackage.menu.isMenuHovered.next(false);\n      this.closetimer = setTimeout(function () {\n        _this6.contextMenuService.closeSubMenu(_this6.menuPackage.menu.id);\n      }, 500);\n    }\n  }, {\n    key: \"handleWindowClick\",\n    value: function handleWindowClick($event) {\n      this.contextMenuService.checkOutsideClick($event);\n    }\n    /** Callback that is invoked when the menu animation completes. */\n\n  }, {\n    key: \"_onAnimationDone\",\n    value: function _onAnimationDone(event) {\n      this._animationDone.next(event);\n    }\n  }]);\n\n  return MenuComponent;\n}();\n\nMenuComponent.ɵfac = function MenuComponent_Factory(t) {\n  return new (t || MenuComponent)(ɵngcc0.ɵɵdirectiveInject(MenuPackage), ɵngcc0.ɵɵdirectiveInject(ContextMenuService));\n};\n\nMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: MenuComponent,\n  selectors: [[\"app-menu\"]],\n  hostBindings: function MenuComponent_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵsyntheticHostListener(\"@menu.done\", function MenuComponent_animation_menu_done_HostBindingHandler($event) {\n        return ctx._onAnimationDone($event);\n      });\n      ɵngcc0.ɵɵlistener(\"mouseover\", function MenuComponent_mouseover_HostBindingHandler() {\n        return ctx.handleMouseover();\n      })(\"mouseleave\", function MenuComponent_mouseleave_HostBindingHandler() {\n        return ctx.handleMouseleave();\n      })(\"click\", function MenuComponent_click_HostBindingHandler($event) {\n        return ctx.handleWindowClick($event);\n      }, false, ɵngcc0.ɵɵresolveDocument);\n    }\n  },\n  decls: 0,\n  vars: 0,\n  template: function MenuComponent_Template(rf, ctx) {},\n  encapsulation: 2\n});\n\nMenuComponent.ctorParameters = function () {\n  return [{\n    type: MenuPackage\n  }, {\n    type: ContextMenuService\n  }];\n};\n\nMenuComponent.propDecorators = {\n  handleMouseover: [{\n    type: HostListener,\n    args: ['mouseover']\n  }],\n  handleMouseleave: [{\n    type: HostListener,\n    args: ['mouseleave']\n  }],\n  handleWindowClick: [{\n    type: HostListener,\n    args: ['document:click', ['$event']]\n  }],\n  _onAnimationDone: [{\n    type: HostListener,\n    args: ['@menu.done', ['$event']]\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MenuComponent, [{\n    type: Component,\n    args: [{\n      selector: 'app-menu',\n      template: \"\"\n    }]\n  }], function () {\n    return [{\n      type: MenuPackage\n    }, {\n      type: ContextMenuService\n    }];\n  }, {\n    handleMouseover: [{\n      type: HostListener,\n      args: ['mouseover']\n    }],\n    handleMouseleave: [{\n      type: HostListener,\n      args: ['mouseleave']\n    }],\n    handleWindowClick: [{\n      type: HostListener,\n      args: ['document:click', ['$event']]\n    }],\n\n    /** Callback that is invoked when the menu animation completes. */\n    _onAnimationDone: [{\n      type: HostListener,\n      args: ['@menu.done', ['$event']]\n    }]\n  });\n})();\n\nvar ContextMenuModule = function ContextMenuModule() {\n  _classCallCheck(this, ContextMenuModule);\n};\n\nContextMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: ContextMenuModule\n});\nContextMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function ContextMenuModule_Factory(t) {\n    return new (t || ContextMenuModule)();\n  },\n  imports: [[PortalModule, OverlayModule]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ContextMenuModule, {\n    declarations: function declarations() {\n      return [ContextMenuTriggerDirective, ContextSubmenuTriggerDirective, MenuComponent];\n    },\n    imports: function imports() {\n      return [PortalModule, OverlayModule];\n    },\n    exports: function exports() {\n      return [ContextMenuTriggerDirective, ContextSubmenuTriggerDirective];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [ContextMenuTriggerDirective, ContextSubmenuTriggerDirective, MenuComponent],\n      exports: [ContextMenuTriggerDirective, ContextSubmenuTriggerDirective],\n      imports: [PortalModule, OverlayModule]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ContextMenuModule, ContextMenuService, ContextMenuTriggerDirective, ContextSubmenuTriggerDirective, MenuComponent, MenuInjector, MenuPackage };","map":{"version":3,"sources":["../../src/lib/context-menu-injector.ts","../../src/lib/context-menu.service.ts","../../src/lib/context-menu-trigger.directive.ts","../../src/lib/context-submenu-trigger.directive.ts","../../src/lib/menu.component.ts","../../src/lib/context-menu.module.ts","../../src/lib/ctrl-ngx-rightclick.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injector, InjectFlags } from '@angular/core';\n\nimport { ActiveContextMenuSub } from './context-menu.service';\n\nexport class MenuPackage {\n  constructor(public menu: ActiveContextMenuSub, public context: any) {}\n}\n\nexport class MenuInjector implements Injector {\n  menuContext: MenuPackage;\n  constructor(\n    private activeContextMenu: ActiveContextMenuSub,\n    private parentInjector: Injector,\n    private context: any,\n  ) {\n    this.menuContext = new MenuPackage(activeContextMenu, context);\n  }\n\n  get<T>(token: any, notFoundValue?: T, flags?: InjectFlags): T | MenuPackage {\n    if (token === MenuPackage) {\n      return this.menuContext;\n    }\n    return this.parentInjector.get<T>(token, notFoundValue, flags);\n  }\n}\n","import {\n  Overlay,\n  OverlayRef,\n  ScrollStrategyOptions,\n} from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { ElementRef, Injectable, Injector, EventEmitter } from '@angular/core';\n\nimport { BehaviorSubject } from 'rxjs';\nimport { filter, take } from 'rxjs/operators';\n\nimport { MenuInjector } from './context-menu-injector';\n\nexport interface ActiveContextMenuSub {\n  id: number;\n  isTriggerHovered: BehaviorSubject<boolean>;\n  isMenuHovered: BehaviorSubject<boolean>;\n  submenu: boolean;\n}\nexport interface ActiveContextMenu extends ActiveContextMenuSub {\n  overlayRef: OverlayRef;\n  component: any;\n  menuClose: EventEmitter<void>;\n  menuAction: EventEmitter<any>;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ContextMenuService {\n  menus: ActiveContextMenu[] = [];\n  id = 0;\n\n  constructor(\n    private overlay: Overlay,\n    private scrollStrategy: ScrollStrategyOptions,\n    private injector: Injector,\n  ) {}\n\n  /**\n   *\n   * @param $event triggering event\n   * @param menuComponent the component to be shown\n   * @param submenu is a menu within a menu\n   * @param level if submenu, what level\n   */\n  show(\n    $event: MouseEvent,\n    menuComponent: any,\n    context: any,\n    menuClose: EventEmitter<any>,\n    menuAction: EventEmitter<any>,\n    submenu = false,\n    level?: number,\n  ): ActiveContextMenu {\n    let target: any;\n    if (!submenu) {\n      this.closeAll();\n      target = {\n        getBoundingClientRect: (): ClientRect => ({\n          bottom: $event.clientY,\n          height: 0,\n          left: $event.clientX,\n          right: $event.clientX,\n          top: $event.clientY,\n          width: 0,\n        }),\n      };\n    } else {\n      // close other submenus\n      this.closeAll(undefined, level);\n      target = $event.target;\n    }\n    const el = new ElementRef(target);\n    const positionStrategy = this.overlay\n      .position()\n      .flexibleConnectedTo(el)\n      .withFlexibleDimensions(false);\n\n    if (!submenu) {\n      positionStrategy.withPositions([\n        {\n          originX: 'start',\n          originY: 'bottom',\n          overlayX: 'start',\n          overlayY: 'top',\n        },\n        {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'bottom',\n        },\n        {\n          originX: 'end',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'top',\n        },\n        {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'end',\n          overlayY: 'top',\n        },\n        {\n          originX: 'end',\n          originY: 'center',\n          overlayX: 'start',\n          overlayY: 'center',\n        },\n        {\n          originX: 'start',\n          originY: 'center',\n          overlayX: 'end',\n          overlayY: 'center',\n        },\n      ]);\n    } else {\n      positionStrategy.withPositions([\n        {\n          originX: 'end',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'top',\n        },\n        {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'end',\n          overlayY: 'top',\n        },\n        {\n          originX: 'end',\n          originY: 'bottom',\n          overlayX: 'start',\n          overlayY: 'bottom',\n        },\n        {\n          originX: 'start',\n          originY: 'bottom',\n          overlayX: 'end',\n          overlayY: 'bottom',\n        },\n      ]);\n    }\n    const t: ActiveContextMenuSub = {\n      submenu,\n      id: this.id++,\n      isMenuHovered: new BehaviorSubject<boolean>(false),\n      isTriggerHovered: new BehaviorSubject<boolean>(false),\n    };\n    const menuInjector = new MenuInjector(t, this.injector, context);\n    const componentPortal = new ComponentPortal(\n      menuComponent,\n      undefined,\n      menuInjector,\n    );\n    const overlayRef = this.overlay.create({\n      positionStrategy,\n      panelClass: 'ngx-contextmenu',\n      scrollStrategy: this.scrollStrategy.close(),\n    });\n    const component = overlayRef.attach<any>(componentPortal);\n    const res = { overlayRef, component, ...t, menuClose, menuAction };\n    this.menus.push(res);\n    return res;\n  }\n  getCurrentLevel() {\n    return this.menus.length;\n  }\n  closeAll(context?: any, idx = 0) {\n    for (let index = idx; index < this.menus.length; index++) {\n      const menu = this.menus[index];\n      this.destroyMenu(menu, context);\n    }\n    this.menus.splice(idx, this.menus.length);\n  }\n  destroyMenu(menu: ActiveContextMenu, context?: any) {\n    menu.component.instance._state = 'exit';\n    if (menu.component.instance.lazy) {\n      menu.component.instance._animationDone\n        .pipe(\n          filter((event: any) => event.toState === 'exit'),\n          take(1),\n        )\n        .subscribe(() => {\n          menu.overlayRef.detach();\n          menu.overlayRef.dispose();\n        });\n    } else {\n      menu.overlayRef.detach();\n      menu.overlayRef.dispose();\n    }\n    if (context) {\n      menu.menuAction.next(context);\n    }\n    menu.menuClose.next();\n  }\n  close(menu: ActiveContextMenu, menuIndex: number, context?: any) {\n    this.destroyMenu(menu, context);\n    this.menus.splice(menuIndex, 1);\n  }\n  checkOutsideClick($event: MouseEvent) {\n    for (const m of this.menus) {\n      const clickedInside = m.component.location.nativeElement.contains(\n        $event.target,\n      );\n      if (clickedInside) {\n        $event.preventDefault();\n        $event.stopPropagation();\n        return;\n      }\n    }\n    this.closeAll();\n  }\n  closeSubMenu(id: number): void {\n    const menuIndex = this.menus.findIndex(n => n.id === id);\n    if (menuIndex === -1 || menuIndex !== this.menus.length - 1) {\n      return;\n    }\n    // make sure we can close the current menu\n    const menu = this.menus[menuIndex];\n    if (menu.isMenuHovered.getValue() || menu.isTriggerHovered.getValue()) {\n      return;\n    }\n    // close all menus up if possible\n    for (let index = this.menus.length - 1; index >= 1; index--) {\n      const m = this.menus[index];\n      if (!m.isMenuHovered.getValue() && !m.isTriggerHovered.getValue()) {\n        this.close(m, index);\n      } else {\n        return;\n      }\n    }\n  }\n}\n","import {\n  Directive,\n  HostListener,\n  Input,\n  Output,\n  EventEmitter,\n  OnDestroy,\n  OnInit,\n} from '@angular/core';\nimport { Subscription } from 'rxjs';\n\nimport { ContextMenuService, ActiveContextMenu } from './context-menu.service';\n\n@Directive({\n  selector: '[contextMenuTrigger]',\n  exportAs: 'contextMenuTrigger',\n})\nexport class ContextMenuTriggerDirective implements OnDestroy, OnInit {\n  @Input() contextMenuTrigger: any;\n  @Input() menuContext: any;\n  @Input() holdToDisplay = 1000;\n  @Output() menuAction = new EventEmitter<any>();\n  @Output() menuClose = new EventEmitter<void>();\n  @Output() beforeOpen = new EventEmitter<any>();\n\n  menu?: ActiveContextMenu;\n  visible = false;\n  private mouseDownTimeoutId: any;\n  private sub!: Subscription;\n\n  @HostListener('contextmenu', ['$event'])\n  handleMenu($event: MouseEvent) {\n    let preventOpen = false;\n    this.beforeOpen.emit({\n      menuContext: this.menuContext,\n      event: $event,\n      preventOpen: () => {\n        preventOpen = true;\n      },\n    });\n\n    if (preventOpen) {\n      return;\n    }\n\n    $event.preventDefault();\n    this.menu = this.contextMenuService.show(\n      $event,\n      this.contextMenuTrigger,\n      this.menuContext,\n      this.menuClose,\n      this.menuAction,\n    );\n    this.visible = true;\n  }\n\n  @HostListener('touchstart', ['$event'])\n  handleMouseDown($event: any) {\n    if (this.holdToDisplay >= 0) {\n      $event.stopPropagation();\n      $event.clientY = $event.touches[0].clientY;\n      $event.clientX = $event.touches[0].clientX;\n\n      this.mouseDownTimeoutId = setTimeout(\n        () => this.handleMenu($event),\n        this.holdToDisplay,\n      );\n    }\n  }\n\n  @HostListener('touchend')\n  handleMouseUp() {\n    clearTimeout(this.mouseDownTimeoutId);\n  }\n\n  constructor(private contextMenuService: ContextMenuService) {}\n\n  ngOnInit() {\n    this.sub = this.menuClose.subscribe(() => (this.visible = false));\n  }\n\n  ngOnDestroy() {\n    this.sub.unsubscribe();\n  }\n}\n","import {\n  Directive,\n  HostListener,\n  Input,\n  OnDestroy,\n  Output,\n  EventEmitter,\n} from '@angular/core';\n\nimport { ActiveContextMenu, ContextMenuService } from './context-menu.service';\n\n@Directive({ selector: '[contextSubmenuTrigger]' })\nexport class ContextSubmenuTriggerDirective implements OnDestroy {\n  @Input() hoverDelay = 500;\n  @Input() openDelay = 200;\n  @Input() contextSubmenuTrigger?: any;\n  @Input() menuContext?: any;\n  @Output() menuAction = new EventEmitter<any>();\n  @Output() menuClose = new EventEmitter<void>();\n  menu?: ActiveContextMenu;\n  opentimer: any;\n  closetimer: any;\n  visible = false;\n  level = 1;\n\n  constructor(private contextMenuService: ContextMenuService) {\n    // get current level\n    setTimeout(() => (this.level = this.contextMenuService.getCurrentLevel()));\n  }\n\n  @HostListener('click', ['$event'])\n  handleSubMenuClick($event: MouseEvent) {\n    $event.preventDefault();\n    $event.stopPropagation();\n    clearTimeout(this.opentimer);\n    clearTimeout(this.closetimer);\n    this.menu = this.contextMenuService.show(\n      $event,\n      this.contextSubmenuTrigger,\n      this.menuContext,\n      this.menuClose,\n      this.menuAction,\n      true,\n      this.level,\n    );\n    this.visible = true;\n  }\n\n  @HostListener('mouseover', ['$event'])\n  handleSubMenuEnter($event: MouseEvent) {\n    if (this.menu) {\n      this.menu.isTriggerHovered.next(true);\n    }\n    clearTimeout(this.closetimer);\n    this.opentimer = setTimeout(() => {\n      this.menu = this.contextMenuService.show(\n        $event,\n        this.contextSubmenuTrigger,\n        this.menuContext,\n        this.menuClose,\n        this.menuAction,\n        true,\n        this.level,\n      );\n      this.visible = true;\n      this.opentimer = null;\n    }, this.openDelay);\n  }\n\n  /**\n   * submenu hides after cursor has exited for a period of time\n   */\n  @HostListener('mouseout')\n  handleSubMenuExit() {\n    clearTimeout(this.opentimer);\n    if (this.menu) {\n      this.menu.isTriggerHovered.next(false);\n    }\n    this.closetimer = setTimeout(() => {\n      if (this.menu) {\n        this.menu.isTriggerHovered.next(false);\n        this.contextMenuService.closeSubMenu(this.menu.id);\n        this.menu = undefined;\n      }\n      this.visible = false;\n    }, this.hoverDelay);\n  }\n\n  /**\n   * if overwritten make sure to clear timeouts\n   */\n  ngOnDestroy() {\n    clearTimeout(this.opentimer);\n    clearTimeout(this.closetimer);\n  }\n}\n","import { Component, HostListener, HostBinding } from '@angular/core';\nimport { AnimationEvent } from '@angular/animations';\n\nimport { ContextMenuService } from './context-menu.service';\nimport { MenuPackage } from './context-menu-injector';\nimport { Subject } from 'rxjs';\n\n@Component({\n  selector: 'app-menu',\n  template: ``,\n})\nexport class MenuComponent {\n  /** State of the dialog animation. */\n  _state: 'void' | 'enter' | 'exit' = 'enter';\n  _animationDone = new Subject<AnimationEvent>();\n  /** set lazy to False if you do not have animations */\n  lazy = true;\n  closetimer: any;\n\n  constructor(\n    public menuPackage: MenuPackage,\n    public contextMenuService: ContextMenuService,\n  ) {}\n\n  @HostListener('mouseover')\n  handleMouseover() {\n    if (!this.menuPackage.menu.submenu) {\n      return;\n    }\n    this.menuPackage.menu.isMenuHovered.next(true);\n    clearTimeout(this.closetimer);\n  }\n\n  @HostListener('mouseleave')\n  handleMouseleave() {\n    if (!this.menuPackage.menu.submenu) {\n      return;\n    }\n    this.menuPackage.menu.isMenuHovered.next(false);\n    this.closetimer = setTimeout(() => {\n      this.contextMenuService.closeSubMenu(this.menuPackage.menu.id);\n    }, 500);\n  }\n\n  @HostListener('document:click', ['$event'])\n  handleWindowClick($event: MouseEvent) {\n    this.contextMenuService.checkOutsideClick($event);\n  }\n\n  /** Callback that is invoked when the menu animation completes. */\n  @HostListener('@menu.done', ['$event'])\n  _onAnimationDone(event: AnimationEvent) {\n    this._animationDone.next(event);\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { OverlayModule } from '@angular/cdk/overlay';\nimport { PortalModule } from '@angular/cdk/portal';\n\nimport { ContextMenuTriggerDirective } from './context-menu-trigger.directive';\nimport { ContextSubmenuTriggerDirective } from './context-submenu-trigger.directive';\nimport { MenuComponent } from './menu.component';\n\n@NgModule({\n  declarations: [\n    ContextMenuTriggerDirective,\n    ContextSubmenuTriggerDirective,\n    MenuComponent,\n  ],\n  exports: [ContextMenuTriggerDirective, ContextSubmenuTriggerDirective],\n  imports: [PortalModule, OverlayModule],\n})\nexport class ContextMenuModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"]},"metadata":{},"sourceType":"module"}